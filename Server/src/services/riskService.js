// Server/src/services/riskService.js
import { Order } from "../models/Order.js";
import { Position } from "../models/Position.js";
import { Settings } from "../models/Settings.js";
import { todayKeyIST } from "../utils/istTime.js";
import { setEngineRunning } from "./engineLoop.js";
import { closeAllPositions, markToMarket } from "./brokerService.js";
function cashflowPnL(orders){ const by=new Map(); for(const o of orders){ const v=by.get(o.symbol)||{buy:0,sell:0}; if(o.side==="BUY") v.buy+=(o.price||0)*(o.qty||0); else v.sell+=(o.price||0)*(o.qty||0); by.set(o.symbol,v);} let realized=0; for(const v of by.values()) realized+=(v.sell-v.buy); return Number(realized.toFixed(2)); }
function capitalInUseFromPositions(ps){ let cap=0; for(const p of ps) cap+=(p.qty||0)*(p.ltp||p.avgPrice||0); return Math.max(0, Math.round(cap)); }
export async function riskSnapshot(){ const s=await Settings.findOne({})||await Settings.create({}); const {dailyLossLimit=5000,maxCapitalUsage=50000}=s.risk||{}; const dayKey=todayKeyIST(); const start=new Date(`${dayKey}T00:00:00.000Z`); const end=new Date(`${dayKey}T23:59:59.999Z`); const orders=await Order.find({ createdAt:{ $gte:start, $lte:end } }); const net=cashflowPnL(orders); await markToMarket(); const positions=await Position.find({}); const capitalInUse=capitalInUseFromPositions(positions); return { dayKey, net, capitalInUse, limits:{ dailyLossLimit, maxCapitalUsage } }; }
export async function ensureRiskLimits(){ const s=await riskSnapshot(); const breachLoss=s.net<=-Math.abs(s.limits.dailyLossLimit); const breachCap=s.capitalInUse>Math.abs(s.limits.maxCapitalUsage); if(breachLoss||breachCap){ const reason=breachLoss?"DAILY_LOSS_LIMIT":"CAP_USAGE_LIMIT"; console.warn(`[RISK] Stopping engine :: ${reason} net=${s.net} cap=${s.capitalInUse}`); await setEngineRunning(false); await closeAllPositions(reason); return { stopped:true, reason, snapshot:s }; } return { stopped:false, snapshot:s }; }
const state={ killSwitch:false, dayLossCap:Number(process.env.RISK_DAY_LOSS||5000), perSymbolLossCap:Number(process.env.RISK_SYMBOL_LOSS||2000), maxOrdersPerMin:Number(process.env.RISK_ORDERS_PER_MIN||30), exposureCap:Number(process.env.RISK_EXPOSURE||1_000_000), counters:{ ordersWindow:[], perSymbolPnl:new Map() } };
export function setKillSwitch(on){ state.killSwitch=!!on; }
export function isKillSwitchOn(){ return state.killSwitch; }
export function updatePerSymbolPnL(symbol, delta){ const v=state.counters.perSymbolPnl.get(symbol)||0; state.counters.perSymbolPnl.set(symbol, v+Number(delta||0)); }
export function checkOrder({ symbol, side, qty, estPrice }){ if(state.killSwitch) throw new Error("Risk: kill switch active"); const notional=Number(qty||0)*Number(estPrice||0); if(notional>state.exposureCap) throw new Error("Risk: exposure cap exceeded"); const symLoss=state.counters.perSymbolPnl.get(symbol)||0; if(symLoss<=-Math.abs(state.perSymbolLossCap)) throw new Error("Risk: symbol loss cap reached"); const now=Date.now(); state.counters.ordersWindow=state.counters.ordersWindow.filter(t=>now-t<60000); if(state.counters.ordersWindow.length>=state.maxOrdersPerMin) throw new Error("Risk: max orders/min reached"); state.counters.ordersWindow.push(now); return true; }
